{"version":3,"sources":["../../src/queries/index.ts","../../src/queries/getDocumentById.ts","../../src/utils/getPayloadContext.ts","../../src/utils/getLocale.ts"],"sourcesContent":["export * from './getDocumentById.js'\n","import type { CollectionSlug, SanitizedConfig } from 'payload'\nimport type { PayloadQuery } from 'src/types.js'\n\nimport { cache } from 'react'\n\nimport { getPayloadContext } from '../utils/getPayloadContext.js'\n\ntype GetDocumentByIdQuery = PayloadQuery<{\n  collection: CollectionSlug\n  id: string\n}>\nexport const getDocumentById = cache(\n  async (config: Promise<SanitizedConfig> | SanitizedConfig, params: GetDocumentByIdQuery) => {\n    try {\n      const { id, collection } = params\n      const { payload, query } = await getPayloadContext(config, params)\n\n      console.info(`Fetching ${collection} with id: ${id}`)\n      const result = await payload.findByID({\n        id,\n        collection,\n        ...query,\n        depth: 30,\n      })\n\n      if (!result) {\n        throw new Error(`Document with id ${id} not found in collection ${collection}`)\n      }\n\n      return result\n    } catch (error) {\n      console.error(error)\n      return null\n    }\n  },\n)\n","import type { SanitizedConfig } from 'payload'\n\nimport { draftMode } from 'next/headers.js'\nimport { getPayload } from 'payload'\n\nimport type { PayloadQuery } from '../types.js'\n\nimport { getLocale } from './getLocale.js'\n\nexport const getPayloadContext = async (\n  config: Promise<SanitizedConfig> | SanitizedConfig,\n  params: PayloadQuery,\n) => {\n  const { isEnabled: draft } = await draftMode()\n  const payload = await getPayload({ config })\n  const processedLocale = getLocale(payload.config, params.locale)\n  const query = {\n    draft,\n    locale: processedLocale,\n    overrideAccess: draft,\n  }\n  return { draft, locale: processedLocale, payload, query }\n}\n","import type { BasePayload, SanitizedConfig } from 'payload'\n\n/**\n * Checks if a given string is a valid locale.\n * @param locale The locale string to validate.\n * @returns The validated locale if valid, otherwise throws an error.\n */\nconst isLocale = (locale: null | string | undefined, localeCodes: string[]): boolean => {\n  if (!locale) {\n    return false\n  }\n\n  return localeCodes.includes(locale)\n}\n\n/**\n * Validates and returns the locale.\n * @param locale The locale string to validate.\n * @returns The validated locale.\n */\nexport const getLocale = (config: SanitizedConfig, locale: null | string | undefined): string => {\n  const { localization } = config\n  if (!localization) {\n    throw new Error(`Localization is not supported by Payload`)\n  }\n  const { defaultLocale, localeCodes } = localization\n\n  if (isLocale(locale, localeCodes)) {\n    return locale as string\n  }\n\n  return defaultLocale\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACGA,mBAAsB;;;ACDtB,qBAA0B;AAC1B,qBAA2B;;;ACI3B,IAAM,WAAW,CAAC,QAAmC,gBAAmC;AACtF,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA,SAAO,YAAY,SAAS,MAAM;AACpC;AAOO,IAAM,YAAY,CAAC,QAAyB,WAA8C;AAC/F,QAAM,EAAE,aAAa,IAAI;AACzB,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AACA,QAAM,EAAE,eAAe,YAAY,IAAI;AAEvC,MAAI,SAAS,QAAQ,WAAW,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ADvBO,IAAM,oBAAoB,OAC/B,QACA,WACG;AACH,QAAM,EAAE,WAAW,MAAM,IAAI,UAAM,0BAAU;AAC7C,QAAM,UAAU,UAAM,2BAAW,EAAE,OAAO,CAAC;AAC3C,QAAM,kBAAkB,UAAU,QAAQ,QAAQ,OAAO,MAAM;AAC/D,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,QAAQ;AAAA,IACR,gBAAgB;AAAA,EAClB;AACA,SAAO,EAAE,OAAO,QAAQ,iBAAiB,SAAS,MAAM;AAC1D;;;ADXO,IAAM,sBAAkB;AAAA,EAC7B,OAAO,QAAoD,WAAiC;AAC1F,QAAI;AACF,YAAM,EAAE,IAAI,WAAW,IAAI;AAC3B,YAAM,EAAE,SAAS,MAAM,IAAI,MAAM,kBAAkB,QAAQ,MAAM;AAEjE,cAAQ,KAAK,YAAY,UAAU,aAAa,EAAE,EAAE;AACpD,YAAM,SAAS,MAAM,QAAQ,SAAS;AAAA,QACpC;AAAA,QACA;AAAA,QACA,GAAG;AAAA,QACH,OAAO;AAAA,MACT,CAAC;AAED,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI,MAAM,oBAAoB,EAAE,4BAA4B,UAAU,EAAE;AAAA,MAChF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,KAAK;AACnB,aAAO;AAAA,IACT;AAAA,EACF;AACF;","names":[]}