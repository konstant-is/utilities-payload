{"version":3,"sources":["../src/utils/field.ts","../src/utils/createField.ts","../src/utils/createFieldOptions.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nconst getBaseProperties = () => {\n  return {}\n}\nexport const field = (props: Field): Field => {\n  const base = getBaseProperties()\n\n  return {\n    ...base,\n    ...props,\n  } as Field\n}\n","import type { Field } from 'payload'\n\nimport { deepMerge } from '@konstant/utilities-ui'\n\nexport type FieldCreateType<P = unknown> = {\n  condition?: (data: any, siblingData: any) => boolean\n  description?: string\n  fields?: Field[]\n  hidden?: boolean\n  hideGutter?: boolean\n  label?: string\n  localized?: boolean\n  name?: string\n  overrides?: Record<string, unknown>\n  required?: boolean\n} & P\n\ntype FieldCreationFunction<P = unknown> = (props: FieldCreateType<P>) => Field\n\nexport function createField<P>(fieldFn: FieldCreationFunction<P>) {\n  return (props: FieldCreateType<P> = {} as FieldCreateType<P>): Field => {\n    // Ensure fieldFn returns a valid Field\n    const field: Field = fieldFn(props)\n\n    const fieldOverrides = {}\n    mergeProp('name', fieldOverrides, props.name)\n    mergeProp('label', fieldOverrides, props.label)\n    mergeProp('localized', fieldOverrides, props.localized)\n    mergeProp('required', fieldOverrides, props.required)\n\n    const adminOverrides = {}\n    mergeProp('condition', adminOverrides, props.condition)\n    mergeProp('description', adminOverrides, props.description)\n    mergeProp('hidden', adminOverrides, props.hidden)\n    mergeProp('hideGutter', adminOverrides, props.hideGutter)\n\n    const result = {\n      ...field,\n      ...fieldOverrides,\n      admin: {\n        ...field.admin,\n        ...adminOverrides,\n      },\n    }\n\n    // Merge overrides with the base field\n    return deepMerge(result, props.overrides || {}) as Field\n  }\n}\n\nconst mergeProp = (key: string, obj: any, value: any) => {\n  obj[`${key}`] = value || undefined\n}\n","import { createObjectKeys, toCapitalized } from '@konstant/utilities-ui'\n\n// Define a utility type to extract the keys from a union type\ntype ExtractKeys<T> = T extends string ? T : never\n\n// Create a generic function to create the record and options based on the type\nexport const createFieldOptions = <T extends string>(keys: ExtractKeys<T>[]) => {\n  const values = createObjectKeys(keys)\n\n  const options = keys.map((key) => ({\n    label: toCapitalized(key),\n    value: key,\n  }))\n\n  return { options, values }\n}\n"],"mappings":";;;;;;;AAEA,IAAM,oBAAoB,MAAM;AAC9B,SAAO,CAAC;AACV;AACO,IAAM,QAAQ,CAAC,UAAwB;AAC5C,QAAM,OAAO,kBAAkB;AAE/B,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AACF;;;ACOO,SAAS,YAAe,SAAmC;AAChE,SAAO,CAAC,QAA4B,CAAC,MAAmC;AAEtE,UAAMA,SAAe,QAAQ,KAAK;AAElC,UAAM,iBAAiB,CAAC;AACxB,cAAU,QAAQ,gBAAgB,MAAM,IAAI;AAC5C,cAAU,SAAS,gBAAgB,MAAM,KAAK;AAC9C,cAAU,aAAa,gBAAgB,MAAM,SAAS;AACtD,cAAU,YAAY,gBAAgB,MAAM,QAAQ;AAEpD,UAAM,iBAAiB,CAAC;AACxB,cAAU,aAAa,gBAAgB,MAAM,SAAS;AACtD,cAAU,eAAe,gBAAgB,MAAM,WAAW;AAC1D,cAAU,UAAU,gBAAgB,MAAM,MAAM;AAChD,cAAU,cAAc,gBAAgB,MAAM,UAAU;AAExD,UAAM,SAAS;AAAA,MACb,GAAGA;AAAA,MACH,GAAG;AAAA,MACH,OAAO;AAAA,QACL,GAAGA,OAAM;AAAA,QACT,GAAG;AAAA,MACL;AAAA,IACF;AAGA,WAAO,iBAAU,QAAQ,MAAM,aAAa,CAAC,CAAC;AAAA,EAChD;AACF;AAEA,IAAM,YAAY,CAAC,KAAa,KAAU,UAAe;AACvD,MAAI,GAAG,GAAG,EAAE,IAAI,SAAS;AAC3B;;;AC9CO,IAAM,qBAAqB,CAAmB,SAA2B;AAC9E,QAAM,SAAS,iBAAiB,IAAI;AAEpC,QAAM,UAAU,KAAK,IAAI,CAAC,SAAS;AAAA,IACjC,OAAO,cAAc,GAAG;AAAA,IACxB,OAAO;AAAA,EACT,EAAE;AAEF,SAAO,EAAE,SAAS,OAAO;AAC3B;","names":["field"]}